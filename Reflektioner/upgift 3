esting and Debugging

Identifying Functionality
Modules to test:

App: API endpoints for retrieving various burgers
API endpoint for submitting orders
Functions for handling order customizations
Database API for retrieving and storing product information
Kitchen View: API endpoint for receiving and displaying orders
Testing Methods
Tests to perform:

Unit Tests: Test each module to ensure they return correct values.
Example: When a user requests to order a burger, the API should return a list of available burgers.
Integration Tests: Test the flow between modules from App to Kitchen View.
Example: When an order is submitted, it should appear in Kitchen View with the correct information.
Error Handling Tests: Simulate incorrect inputs and ensure the system handles them correctly.
Example: What happens if a user tries to order a non-existent item?
Test Runs

Regular Testing: Run tests after each major functional change to ensure nothing breaks.
Conducted cross-browser testing to verify that the website functions correctly on different browsers.
Run tests when making commits to check that no new bugs arise.
When Tests Fail: When encountering issues, we discussed the error within the team to find solutions that address the problem.
This plan provides a good overview of how we structured our tests to ensure our application is robust and functions as intended!
During our testing process, we focused on carefully debugging specific parts of our code. One key aspect was checking the communication between app.py and kitchen.py. In kitchen.py, we implemented a response for "Order received" that would be triggered when app.py sent information. To carry out the tests, we created temporary burgers, allowing us to simulate orders despite previous issues with the database.

We continued to work on the code until we eventually received a correct response. During this process, we encountered several issues. A specific example was when we mistakenly specified POST in app.py instead of GET for kitchen.py. This incorrect method led to information not being sent or received correctly, breaking the communication between the two files. By identifying and correcting this mistake, we restored the intended functionality and ensured that kitchen.py received the information as intended. This example highlights the importance of debugging in solving problems and improving code functionality.

We also conducted similar tests for the SQL database. To ensure the database could communicate correctly with the code, we implemented a print function. This helped us determine whether the issue lay with the database or in the communication between the database and the code. We discovered that the code was correct, but the connection to the local Docker MySQL database was not functioning as intended. After careful consideration, we decided to switch to PostgreSQL. Following this change, everything worked as it should, after some adjustments.

By carefully testing and troubleshooting each step, we have ensured that our system now functions as intended.